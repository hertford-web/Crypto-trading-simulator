<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Crypto Trading Simulator (Improved Single File)</title>

  <!-- React / ReactDOM UMD for quick demo -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel standalone so we can use JSX in a single HTML file demo -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Decimal library to avoid floating point money inaccuracies -->
  <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>

  <!-- Tailwind (optional styling convenience) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    /**
     * Improved single-file version of the simulator:
     * - Uses Decimal.js for monetary math
     * - Avoids stale state updates by using functional updates
     * - Safe localStorage helpers + only remove own keys on reset
     * - Safe fetch wrapper with retries
     * - Debounced AI generation
     * - No embedded private API keys (economic data simulated / fallback)
     * - Non-blocking messages instead of alert()
     */

    const LS_KEYS = {
      PORTFOLIO: 'cts_portfolio',
      BALANCE: 'cts_balance',
      HISTORY: 'cts_tradeHistory',
      EMAIL: 'cts_userEmail',
      ALERTS: 'cts_emailAlerts'
    };

    function safeGet(key, fallback = null) {
      try {
        const v = localStorage.getItem(key);
        if (v === null) return fallback;
        return JSON.parse(v);
      } catch (e) {
        console.warn('localStorage get error', e);
        return fallback;
      }
    }
    function safeSet(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch (e) {
        console.warn('localStorage set error', e);
      }
    }
    function safeRemove(key) {
      try { localStorage.removeItem(key); } catch (e) { /* ignore */ }
    }

    async function fetchJson(url, opts = {}, retries = 2, backoffMs = 800) {
      try {
        const res = await fetch(url, opts);
        if (!res.ok) {
          if (retries > 0 && (res.status === 429 || res.status >= 500)) {
            await new Promise(r => setTimeout(r, backoffMs));
            return fetchJson(url, opts, retries - 1, backoffMs * 1.5);
          }
          const txt = await res.text();
          throw new Error(`Fetch ${url} failed: ${res.status} ${txt}`);
        }
        return res.json();
      } catch (err) {
        if (retries > 0) {
          await new Promise(r => setTimeout(r, backoffMs));
          return fetchJson(url, opts, retries - 1, backoffMs * 1.5);
        }
        console.error('fetchJson error', err);
        throw err;
      }
    }

    const FEE_PCT = new Decimal(0.001); // 0.1% fee

    function fmtUSD(value) {
      try {
        return new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' }).format(value);
      } catch {
        return `$${Number(value).toFixed(2)}`;
      }
    }

    const cryptos = [
      { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin' },
      { id: 'ethereum', symbol: 'ETH', name: 'Ethereum' },
      { id: 'solana', symbol: 'SOL', name: 'Solana' },
      { id: 'cardano', symbol: 'ADA', name: 'Cardano' },
      { id: 'ripple', symbol: 'XRP', name: 'XRP' }
    ];

    function App() {
      const [portfolio, setPortfolio] = useState(() => safeGet(LS_KEYS.PORTFOLIO, []));
      const [balance, setBalance] = useState(() => {
        const val = safeGet(LS_KEYS.BALANCE, null);
        return val !== null ? Number(val) : 10000;
      });
      const [prices, setPrices] = useState({});
      const [loading, setLoading] = useState(true);
      const [message, setMessage] = useState('');
      const [historicalData, setHistoricalData] = useState({});
      const [aiSuggestions, setAiSuggestions] = useState([]);
      const [economicData, setEconomicData] = useState(null);
      const [sentiment, setSentiment] = useState('neutral');
      const [selectedCrypto, setSelectedCrypto] = useState('bitcoin');
      const [tradeAmount, setTradeAmount] = useState('');
      const [tradeHistory, setTradeHistory] = useState(() => safeGet(LS_KEYS.HISTORY, []));
      const [userEmail, setUserEmail] = useState(() => safeGet(LS_KEYS.EMAIL, ''));
      const [emailAlerts, setEmailAlerts] = useState(() => safeGet(LS_KEYS.ALERTS, false) === true);
      const [showHistory, setShowHistory] = useState(false);
      const [fearGreedIndex, setFearGreedIndex] = useState(null);
      const [vixIndex, setVixIndex] = useState(null);
      const [dollarIndex, setDollarIndex] = useState(null);

      const aiTimer = useRef(null);
      const messageTimer = useRef(null);

      // Derived totals using Decimal to avoid float errors
      const totalValue = useMemo(() => {
        try {
          return portfolio.reduce((sum, h) => {
            const p = prices[h.symbol];
            if (!p) return sum;
            return new Decimal(sum).plus(new Decimal(h.amount).times(new Decimal(p.price))).toNumber();
          }, 0);
        } catch (e) {
          return 0;
        }
      }, [portfolio, prices]);

      const total = useMemo(() => {
        try {
          return new Decimal(balance).plus(new Decimal(totalValue)).toNumber();
        } catch (e) {
          return balance + totalValue;
        }
      }, [balance, totalValue]);

      // Messaging helper (non-blocking)
      const showMessage = useCallback((msg, ms = 5000) => {
        setMessage(msg);
        if (messageTimer.current) clearTimeout(messageTimer.current);
        if (ms > 0) {
          messageTimer.current = setTimeout(() => setMessage(''), ms);
        }
      }, []);

      // Persist to localStorage safely (only our keys)
      useEffect(() => safeSet(LS_KEYS.PORTFOLIO, portfolio), [portfolio]);
      useEffect(() => safeSet(LS_KEYS.BALANCE, balance), [balance]);
      useEffect(() => safeSet(LS_KEYS.HISTORY, tradeHistory), [tradeHistory]);
      useEffect(() => safeSet(LS_KEYS.EMAIL, userEmail), [userEmail]);
      useEffect(() => safeSet(LS_KEYS.ALERTS, emailAlerts), [emailAlerts]);

      useEffect(() => {
        // Initial data fetches
        (async () => {
          await fetchPrices();
          await fetchHistorical();
          // economic data is sensitive (often requires API keys) â€” use server-side in production
          await fetchFearGreed();
          // Simulate economic data for the demo
          setEconomicData({ inflation: 3.2, fedRate: 4.5, gdpGrowth: 2.5, unemployment: 4.0 });
          analyzeSentiment(3.2, 4.5, 2.5, 4.0);
          setLoading(false);
        })();
      }, []);

      useEffect(() => {
        // When historical data becomes available we can simulate VIX/DXY
        if (Object.keys(historicalData).length > 0) {
          computeVIXAndDollar();
        }
      }, [historicalData]);

      // Debounced AI generator when prices/historical/portfolio change
      useEffect(() => {
        if (aiTimer.current) clearTimeout(aiTimer.current);
        aiTimer.current = setTimeout(() => {
          generateAI();
        }, 450);
        return () => {
          if (aiTimer.current) clearTimeout(aiTimer.current);
        };
      }, [prices, historicalData, portfolio, economicData, fearGreedIndex, vixIndex, dollarIndex, sentiment, emailAlerts, userEmail]);

      async function fetchPrices() {
        try {
          const ids = cryptos.map(c => c.id).join(',');
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24h_change=true`;
          const data = await fetchJson(url);
          const p = {};
          cryptos.forEach(c => {
            if (data[c.id]) {
              p[c.symbol] = {
                price: Number(data[c.id].usd),
                change: Number(data[c.id].usd_24h_change || 0)
              };
            }
          });
          setPrices(p);
        } catch (e) {
          console.warn('fetchPrices failed, using empty prices', e);
        }
      }

      async function fetchHistorical() {
        try {
          const promises = cryptos.map(async c => {
            const res = await fetchJson(`https://api.coingecko.com/api/v3/coins/${c.id}/market_chart?vs_currency=usd&days=7&interval=daily`);
            return { symbol: c.symbol, data: Array.isArray(res.prices) ? res.prices : [] };
          });
          const results = await Promise.all(promises);
          const h = {};
          results.forEach(r => { h[r.symbol] = r.data; });
          setHistoricalData(h);
        } catch (e) {
          console.warn('fetchHistorical failed', e);
        }
      }

      async function fetchFearGreed() {
        try {
          const data = await fetchJson('https://api.alternative.me/fng/?limit=1');
          if (data && Array.isArray(data.data) && data.data.length > 0) {
            const fgValue = parseInt(data.data[0].value, 10);
            const fgClassification = data.data[0].value_classification;
            setFearGreedIndex({ value: fgValue, label: fgClassification });
          } else {
            setFearGreedIndex({ value: 50, label: 'Neutral' });
          }
        } catch (e) {
          console.warn('Fear & Greed fetch failed; using neutral', e);
          setFearGreedIndex({ value: 50, label: 'Neutral' });
        }
      }

      function computeVIXAndDollar() {
        try {
          const btcHist = historicalData['BTC'] || historicalData['BTC'];
          // very simple volatility calc (demo)
          if (btcHist && btcHist.length > 1) {
            const vol = calcVolatility(btcHist);
            const simulatedVIX = Math.min(80, Math.max(10, vol * 5));
            setVixIndex(simulatedVIX);
          } else {
            setVixIndex(20);
          }
          setDollarIndex(105); // demo fallback
        } catch (e) {
          console.warn('computeVIXAndDollar error', e);
          setVixIndex(20);
          setDollarIndex(105);
        }
      }

      function analyzeSentiment(inflation, fedRate, gdpGrowth, unemp) {
        let s = 'neutral';
        let score = 0;

        if (inflation > 4) score -= 2;
        else if (inflation < 2) score += 1;

        if (fedRate > 5) score -= 2;
        else if (fedRate < 3) score += 2;

        if (gdpGrowth > 2.5) score += 2;
        else if (gdpGrowth < 1) score -= 2;

        if (unemp > 5) score -= 1;
        else if (unemp < 4) score += 1;

        if (fearGreedIndex) {
          if (fearGreedIndex.value > 70) score += 1;
          else if (fearGreedIndex.value < 30) score += 2;
        }

        if (vixIndex) {
          if (vixIndex > 30) score -= 1;
          else if (vixIndex < 15) score += 1;
        }

        if (dollarIndex) {
          if (dollarIndex > 110) score -= 1;
          else if (dollarIndex < 100) score += 1;
        }

        if (score >= 3) s = 'bullish';
        else if (score >= 1) s = 'optimistic';
        else if (score <= -3) s = 'bearish';
        else if (score <= -1) s = 'cautious';
        else s = 'neutral';

        setSentiment(s);
      }

      //
      // Indicators (unchanged logic, but defensive)
      //
      function calcRSI(data, period = 14) {
        if (!Array.isArray(data) || data.length < period + 1) return 50;
        const changes = [];
        for (let i = 1; i < data.length; i++) changes.push(data[i][1] - data[i - 1][1]);
        const recent = changes.slice(-period);
        const gains = recent.filter(c => c > 0).reduce((a, b) => a + b, 0) / period;
        const losses = Math.abs(recent.filter(c => c < 0).reduce((a, b) => a + b, 0)) / period;
        if (losses === 0) return 100;
        return 100 - (100 / (1 + gains / losses));
      }

      function calcSMA(data, period) {
        if (!Array.isArray(data) || data.length < period) return null;
        const slice = data.slice(-period);
        return slice.reduce((a, v) => a + v[1], 0) / period;
      }

      function calcVolatility(data) {
        if (!Array.isArray(data) || data.length < 2) return 0;
        const returns = [];
        for (let i = 1; i < data.length; i++) returns.push((data[i][1] - data[i - 1][1]) / data[i - 1][1]);
        const variance = returns.reduce((sum, r) => sum + r * r, 0) / returns.length;
        return Math.sqrt(variance) * 100;
      }

      //
      // AI suggestion generator (debounced by useEffect above)
      //
      function generateAI() {
        try {
          if (Object.keys(prices).length === 0 || Object.keys(historicalData).length === 0) {
            setAiSuggestions([]);
            return;
          }

          const suggestions = [];
          let sentimentMult = 1.0;
          if (sentiment === 'bullish') sentimentMult = 1.5;
          else if (sentiment === 'optimistic') sentimentMult = 1.2;
          else if (sentiment === 'cautious') sentimentMult = 0.8;
          else if (sentiment === 'bearish') sentimentMult = 0.5;

          if (fearGreedIndex) {
            if (fearGreedIndex.value < 25) sentimentMult *= 1.2;
            else if (fearGreedIndex.value > 75) sentimentMult *= 0.8;
          }

          cryptos.forEach(c => {
            const p = prices[c.symbol];
            const h = historicalData[c.symbol];
            if (!p || !h) return;

            const rsi = calcRSI(h);
            const sma7 = calcSMA(h, 7);
            const volatility = calcVolatility(h);
            const holding = portfolio.find(x => x.symbol === c.symbol);

            let score = 0;
            const reasons = [];

            if (!holding) {
              if (rsi < 35) { score += 2 * sentimentMult; reasons.push(`Oversold RSI ${Math.round(rsi)}`); }
              if (sma7 && p.price < sma7 * 0.98) { score += 1.5 * sentimentMult; reasons.push('Below 7-day MA'); }
              if (p.change < -3 && p.change > -8) { score += 1 * sentimentMult; reasons.push(`Dip ${p.change.toFixed(1)}%`); }
              if (volatility < 3) { score += 0.5; reasons.push('Low volatility'); }
              if (sentiment === 'bullish') { score += 1; reasons.push('Bullish macro'); }
              if (fearGreedIndex && fearGreedIndex.value < 30) { score += 1; reasons.push(`Fear: ${fearGreedIndex.value}`); }

              if (score >= 2 && reasons.length > 0) {
                suggestions.push({
                  id: c.id,
                  symbol: c.symbol,
                  action: 'BUY',
                  reason: reasons.join(', '),
                  price: p.price,
                  amount: 0.1,
                  confidence: score >= 4 ? 'High' : score >= 3 ? 'Medium' : 'Low',
                  score
                });
              }
            } else {
              score = 0;
              reasons.length = 0;
              const pl = ((p.price - holding.buyPrice) / holding.buyPrice) * 100;

              if (pl > 10) { score += 3; reasons.push(`Take profit +${pl.toFixed(1)}%`); }
              else if (pl > 5) { score += 1.5; reasons.push(`Good profit +${pl.toFixed(1)}%`); }
              if (rsi > 70) { score += 2; reasons.push(`Overbought RSI ${Math.round(rsi)}`); }
              if (sma7 && p.price > sma7 * 1.05) { score += 1; reasons.push('Extended above MA'); }
              if (pl < -8) { score += 2.5; reasons.push(`Stop-loss ${pl.toFixed(1)}%`); }
              if (volatility > 5) { score += 0.5; reasons.push('High volatility'); }

              if (score >= 2 && reasons.length > 0) {
                suggestions.push({
                  id: c.id,
                  symbol: c.symbol,
                  action: 'SELL',
                  reason: reasons.join(', '),
                  price: p.price,
                  amount: holding.amount,
                  confidence: score >= 4 ? 'High' : score >= 3 ? 'Medium' : 'Low',
                  score
                });
              }
            }
          });

          suggestions.sort((a, b) => b.score - a.score);
          setAiSuggestions(suggestions.slice(0, 6));

          // Simulated email alerts: in production, send email server-side
          if (emailAlerts && userEmail) {
            suggestions.forEach(s => {
              if (s.confidence === 'High') {
                sendEmailAlert(s);
              }
            });
          }
        } catch (e) {
          console.error('AI generation error', e);
        }
      }

      function addToHistory(type, cryptoSymbol, amountNum, priceNum, profit = null) {
        const trade = {
          id: (crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : Date.now().toString(36) + Math.random().toString(36).slice(2),
          timestamp: new Date().toISOString(),
          type,
          crypto: cryptoSymbol,
          amount: Number(amountNum),
          price: Number(priceNum),
          total: Number(new Decimal(amountNum).times(priceNum).toNumber()),
          profit: profit === null ? null : Number(profit)
        };
        setTradeHistory(prev => [trade, ...prev].slice(0, 50));
      }

      async function sendEmailAlert(suggestion) {
        if (!emailAlerts || !userEmail) return;
        // Demo mode: log to console and show a UI message
        console.log(`Email Alert (simulated) to ${userEmail}:`, suggestion);
        showMessage(`ðŸ“§ Simulated email alert for ${suggestion.action} ${suggestion.symbol}`, 4000);
        // In production: POST to your backend endpoint which sends the email securely
      }

      //
      // Trading operations (use Decimal and functional updates)
      //
      const buy = useCallback((id, amt) => {
        try {
          const amtNum = Number(amt);
          if (!amt || isNaN(amtNum) || amtNum <= 0) {
            showMessage('Invalid buy amount', 3000);
            return;
          }
          const c = cryptos.find(x => x.id === id);
          if (!c) return;
          const p = prices[c.symbol];
          if (!p) { showMessage('Price unavailable', 3000); return; }

          const amtDec = new Decimal(amtNum);
          const priceDec = new Decimal(p.price);
          const cost = amtDec.times(priceDec).times(Decimal(1).plus(FEE_PCT)); // includes fee

          setBalance(prev => {
            const prevDec = new Decimal(prev);
            if (prevDec.lt(cost)) {
              showMessage(`Insufficient funds. Need ${fmtUSD(cost.toNumber())}`, 4000);
              return prev;
            }
            return prevDec.minus(cost).toNumber();
          });

          setPortfolio(prev => {
            const existing = prev.find(x => x.id === id);
            if (existing) {
              const newAmt = new Decimal(existing.amount).plus(amtDec);
              const newAvg = new Decimal(existing.buyPrice).times(existing.amount)
                .plus(priceDec.times(amtDec))
                .dividedBy(newAmt);
              return prev.map(x => x.id === id ? { ...x, amount: newAmt.toNumber(), buyPrice: newAvg.toNumber() } : x);
            } else {
              return [...prev, { id: c.id, symbol: c.symbol, amount: amtDec.toNumber(), buyPrice: priceDec.toNumber() }];
            }
          });

          addToHistory('BUY', c.symbol, amtNum, p.price, null);
          showMessage(`âœ… Bought ${amtNum} ${c.symbol} for ${fmtUSD(new Decimal(amtNum).times(p.price).times(Decimal(1).plus(FEE_PCT))).toString()}`, 4000);
          setTradeAmount('');
        } catch (e) {
          console.error('buy error', e);
          showMessage('Buy failed (see console)', 4000);
        }
      }, [prices, setPortfolio, setBalance, showMessage]);

      const sell = useCallback((id, amt) => {
        try {
          const amtNum = Number(amt);
          if (!amt || isNaN(amtNum) || amtNum <= 0) {
            showMessage('Invalid sell amount', 3000);
            return;
          }
          const h = portfolio.find(x => x.id === id);
          if (!h) { showMessage('Holding not found', 3000); return; }
          if (amtNum > h.amount + 1e-12) { showMessage(`Only have ${h.amount.toFixed(6)} ${h.symbol}`, 4000); return; }

          const p = prices[h.symbol];
          if (!p) { showMessage('Price unavailable', 3000); return; }

          const amtDec = new Decimal(amtNum);
          const priceDec = new Decimal(p.price);
          const revenue = amtDec.times(priceDec).times(Decimal(1).minus(FEE_PCT)); // after fee
          const profit = revenue.minus(amtDec.times(new Decimal(h.buyPrice)));

          setBalance(prev => new Decimal(prev).plus(revenue).toNumber());

          setPortfolio(prev => {
            if (Math.abs(amtNum - h.amount) < 1e-12) {
              return prev.filter(x => x.id !== id);
            } else {
              return prev.map(x => x.id === id ? { ...x, amount: new Decimal(x.amount).minus(amtDec).toNumber() } : x);
            }
          });

          addToHistory('SELL', h.symbol, amtNum, p.price, profit.toNumber());
          showMessage(`âœ… Sold ${amtNum} ${h.symbol} for ${fmtUSD(revenue.toNumber())} (${profit.gte(0) ? 'Profit' : 'Loss'}: ${fmtUSD(profit.toNumber())})`, 5000);
          setTradeAmount('');
        } catch (e) {
          console.error('sell error', e);
          showMessage('Sell failed (see console)', 4000);
        }
      }, [portfolio, prices, showMessage]);

      function reset() {
        if (!confirm('Reset portfolio? This will clear simulator state saved here.')) return;
        setPortfolio([]);
        setBalance(10000);
        setTradeHistory([]);
        // remove only our keys
        Object.values(LS_KEYS).forEach(k => safeRemove(k));
        showMessage('Reset complete', 3000);
      }

      // UI render
      if (loading) {
        return (
          <div className="min-h-screen flex items-center justify-center">
            <p className="text-white text-2xl">Loading...</p>
          </div>
        );
      }

      return (
        <div className="min-h-screen p-6">
          <div className="max-w-6xl mx-auto">
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-3xl font-bold text-white">Crypto Simulator (Improved)</h1>
              <div className="flex items-center gap-3">
                <button onClick={reset} className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-bold">Reset</button>
                <button onClick={() => setShowHistory(true)} className="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-bold">History</button>
              </div>
            </div>

            {message && (
              <div className="bg-blue-500/10 border border-blue-500 rounded-lg p-3 mb-4">
                <p className="text-blue-300">{message}</p>
              </div>
            )}

            {/* Summary */}
            <div className="grid grid-cols-3 gap-4 mb-6">
              <div className="bg-white/5 rounded-xl p-4">
                <p className="text-purple-300 text-sm">Cash</p>
                <p className="text-2xl font-bold text-white">{fmtUSD(balance)}</p>
              </div>
              <div className="bg-white/5 rounded-xl p-4">
                <p className="text-purple-300 text-sm">Portfolio</p>
                <p className="text-2xl font-bold text-white">{fmtUSD(totalValue)}</p>
              </div>
              <div className="bg-white/5 rounded-xl p-4">
                <p className="text-purple-300 text-sm">Total</p>
                <p className="text-2xl font-bold text-white">{fmtUSD(total)}</p>
              </div>
            </div>

            <div className="grid lg:grid-cols-3 gap-6">
              {/* Main trading panel */}
              <div className="lg:col-span-2 space-y-6">
                <div className="bg-white/5 rounded-xl p-6">
                  <h2 className="text-xl font-bold text-white mb-4">Trade Crypto</h2>

                  <div className="space-y-4">
                    <div>
                      <label className="text-purple-300 text-sm mb-2 block">Select Crypto</label>
                      <select
                        value={selectedCrypto}
                        onChange={(e) => setSelectedCrypto(e.target.value)}
                        className="w-full bg-slate-800 text-white rounded-lg p-3 border border-purple-500/30"
                      >
                        {cryptos.map(c => <option key={c.id} value={c.id}>{c.symbol} - {c.name}</option>)}
                      </select>
                    </div>

                    <div>
                      <label className="text-purple-300 text-sm mb-2 block">Amount</label>
                      <input
                        type="number"
                        value={tradeAmount}
                        onChange={(e) => setTradeAmount(e.target.value)}
                        placeholder="Enter amount"
                        step="0.0001"
                        className="w-full bg-slate-800 text-white rounded-lg p-3 border border-purple-500/30"
                      />
                    </div>

                    <div className="bg-slate-800/50 rounded-lg p-3">
                      {(() => {
                        const c = cryptos.find(x => x.id === selectedCrypto);
                        const p = prices[c?.symbol];
                        const amt = Number(tradeAmount) || 0;
                        const cost = (() => {
                          if (!p || amt <= 0) return null;
                          return new Decimal(amt).times(new Decimal(p.price)).times(Decimal(1).plus(FEE_PCT)).toNumber();
                        })();
                        return (
                          <>
                            <p className="text-purple-300 text-sm">Price: {p ? fmtUSD(p.price) : 'â€”'}</p>
                            {amt > 0 && <p className="text-white font-bold mt-1">Total: {cost ? fmtUSD(cost) : 'â€”'}</p>}
                          </>
                        );
                      })()}
                    </div>

                    <div className="flex gap-3">
                      <button
                        onClick={() => {
                          const amt = Number(tradeAmount);
                          if (amt > 0) buy(selectedCrypto, amt);
                          else showMessage('Enter an amount to buy', 3000);
                        }}
                        className="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg"
                      >
                        BUY
                      </button>
                      <button
                        onClick={() => {
                          const amt = Number(tradeAmount);
                          if (amt > 0) {
                            // Find id for selected crypto in portfolio
                            const entry = portfolio.find(x => x.id === selectedCrypto);
                            if (entry) sell(selectedCrypto, amt);
                            else showMessage('You do not hold this coin', 3000);
                          } else showMessage('Enter an amount to sell', 3000);
                        }}
                        className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg"
                      >
                        SELL
                      </button>
                    </div>
                  </div>

                  <div className="mt-4 grid grid-cols-3 gap-2">
                    <button onClick={() => setTradeAmount('0.1')} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm">0.1</button>
                    <button onClick={() => setTradeAmount('1')} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm">1.0</button>
                    <button onClick={() => setTradeAmount('5')} className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm">5.0</button>
                  </div>
                </div>

                <div className="bg-white/5 rounded-xl p-6">
                  <h2 className="text-xl font-bold text-white mb-4">Price Chart (List)</h2>
                  <div className="space-y-3">
                    {cryptos.map(c => {
                      const p = prices[c.symbol];
                      if (!p) return null;
                      return (
                        <div key={c.id} className="bg-slate-800/50 rounded-lg p-4 flex justify-between items-center">
                          <div>
                            <h3 className="text-lg font-bold text-white">{c.symbol}</h3>
                            <p className="text-purple-300 text-sm">{fmtUSD(p.price)}</p>
                            <p className={`text-xs ${p.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                              {p.change >= 0 ? '+' : ''}{p.change.toFixed(2)}%
                            </p>
                          </div>
                          <button
                            onClick={() => { setSelectedCrypto(c.id); setTradeAmount('0.1'); }}
                            className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-bold"
                          >
                            Select
                          </button>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>

              {/* Right column: holdings & AI */}
              <div className="space-y-6">
                <div className="bg-white/5 rounded-xl p-6">
                  <h2 className="text-xl font-bold text-white mb-4">Your Holdings</h2>
                  {portfolio.length === 0 ? (
                    <p className="text-purple-300">No holdings yet. Start trading!</p>
                  ) : (
                    <div className="space-y-3">
                      {portfolio.map(h => {
                        const p = prices[h.symbol];
                        if (!p) return null;
                        const value = new Decimal(h.amount).times(new Decimal(p.price)).toNumber();
                        const pl = new Decimal(value).minus(new Decimal(h.amount).times(new Decimal(h.buyPrice))).toNumber();
                        const plPercent = new Decimal(pl).dividedBy(new Decimal(h.amount).times(new Decimal(h.buyPrice))).times(100).toNumber();
                        return (
                          <div key={h.id} className="bg-slate-800/50 rounded-lg p-4">
                            <div className="flex justify-between items-start mb-2">
                              <div>
                                <h3 className="text-lg font-bold text-white">{h.symbol}</h3>
                                <p className="text-purple-300 text-sm">{h.amount.toFixed(6)} coins</p>
                                <p className={`text-sm ${pl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                  {pl >= 0 ? '+' : ''}{fmtUSD(pl)} ({plPercent.toFixed(1)}%)
                                </p>
                              </div>
                              <div className="text-right">
                                <p className="text-xl font-bold text-white">{fmtUSD(value)}</p>
                              </div>
                            </div>
                            <button onClick={() => sell(h.id, h.amount)} className="w-full bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg font-bold mt-2">Sell All</button>
                            <button onClick={() => { setSelectedCrypto(h.id); setTradeAmount((h.amount / 2).toFixed(6)); }} className="w-full bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-lg font-bold mt-2">Sell Half</button>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>

                <div className="bg-white/5 rounded-xl p-6">
                  <h2 className="text-xl font-bold text-white mb-4">ðŸ¤– AI Recommendations</h2>

                  {economicData && (
                    <div className="bg-slate-800/50 rounded-lg p-3 mb-4">
                      <p className="text-xs text-purple-300 mb-1">Market Sentiment</p>
                      <p className={`font-bold text-lg ${sentiment === 'bullish' ? 'text-green-400' : sentiment === 'bearish' ? 'text-red-400' : 'text-yellow-300'}`}>
                        {sentiment.toUpperCase()}
                      </p>
                      <div className="grid grid-cols-2 gap-2 mt-2 text-xs text-purple-300">
                        <div>ðŸ’° Inflation: {economicData.inflation}%</div>
                        <div>ðŸ“Š Fed Rate: {economicData.fedRate}%</div>
                        <div>ðŸ“ˆ GDP: {economicData.gdpGrowth}%</div>
                        <div>ðŸ‘¥ Unemp: {economicData.unemployment}%</div>
                      </div>
                    </div>
                  )}

                  <div className="bg-slate-800/50 rounded-lg p-3 mb-4">
                    <p className="text-xs text-purple-300 mb-2 font-bold">Advanced Indicators</p>
                    <div className="space-y-1 text-xs">
                      {fearGreedIndex && (
                        <div className="flex justify-between">
                          <span className="text-purple-400">ðŸ˜± Fear & Greed:</span>
                          <span className={`font-bold ${fearGreedIndex.value < 25 ? 'text-red-400' : fearGreedIndex.value > 75 ? 'text-green-400' : 'text-yellow-400'}`}>
                            {fearGreedIndex.value} ({fearGreedIndex.label})
                          </span>
                        </div>
                      )}
                      {vixIndex != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-400">ðŸ“‰ VIX (sim):</span>
                          <span className={`font-bold ${vixIndex > 30 ? 'text-red-400' : vixIndex < 15 ? 'text-green-400' : 'text-yellow-400'}`}>
                            {vixIndex.toFixed(1)}
                          </span>
                        </div>
                      )}
                      {dollarIndex != null && (
                        <div className="flex justify-between">
                          <span className="text-purple-400">ðŸ’µ Dollar Index:</span>
                          <span className={`font-bold ${dollarIndex > 110 ? 'text-red-400' : dollarIndex < 100 ? 'text-green-400' : 'text-yellow-400'}`}>
                            {dollarIndex.toFixed(1)}
                          </span>
                        </div>
                      )}
                    </div>
                    <p className="text-xs text-purple-400 mt-2">ðŸŸ¢ Green = Bullish | ðŸ”´ Red = Bearish</p>
                  </div>

                  <div className="bg-slate-800/50 rounded-lg p-3 mb-4">
                    <p className="text-xs text-purple-300 mb-2">ðŸ“§ Email Alerts (High Confidence Only)</p>
                    <input
                      type="email"
                      value={userEmail}
                      onChange={(e) => setUserEmail(e.target.value)}
                      placeholder="your@email.com"
                      className="w-full bg-slate-900 text-white rounded px-2 py-1 text-xs mb-2 border border-purple-500/30"
                    />
                    <label className="flex items-center gap-2 text-xs text-white cursor-pointer">
                      <input type="checkbox" checked={emailAlerts} onChange={(e) => setEmailAlerts(e.target.checked)} className="rounded" />
                      Enable alerts (simulated)
                    </label>
                    <p className="text-xs text-purple-400 mt-1">* Alerts are simulated in this demo</p>
                  </div>

                  {aiSuggestions.length === 0 ? (
                    <p className="text-purple-300 text-sm">Analyzing markets...</p>
                  ) : (
                    <div className="space-y-3">
                      {aiSuggestions.map(s => (
                        <div key={s.id} className="bg-slate-800/50 rounded-lg p-3 border-l-4 border-purple-500">
                          <div className="flex justify-between items-start mb-2">
                            <div>
                              <h3 className="font-bold text-white">{s.symbol}</h3>
                              <p className="text-xs text-purple-300">{fmtUSD(s.price)}</p>
                            </div>
                            <span className={`px-2 py-1 rounded text-xs font-bold ${s.action === 'BUY' ? 'bg-green-600' : 'bg-red-600'} text-white`}>
                              {s.action}
                            </span>
                          </div>
                          <p className="text-xs text-purple-300 mb-2">{s.reason}</p>
                          <div className="flex justify-between items-center mb-2">
                            <span className={`text-xs px-2 py-1 rounded ${s.confidence === 'High' ? 'bg-green-600/30 text-green-300' : 'bg-yellow-600/30 text-yellow-300'}`}>
                              {s.confidence}
                            </span>
                          </div>
                          <button
                            onClick={() => { if (s.action === 'BUY') buy(s.id, s.amount); else sell(s.id, s.amount); }}
                            className={`w-full font-bold py-2 rounded-lg ${s.action === 'BUY' ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'} text-white`}
                          >
                            Execute {s.action} {s.amount.toFixed(4)} {s.symbol}
                          </button>
                        </div>
                      ))}
                    </div>
                  )}

                </div>
              </div>
            </div>

            {/* Trade History Modal (simple) */}
            {showHistory && (
              <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4">
                <div className="bg-slate-900 rounded-lg p-6 w-full max-w-3xl">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-white">ðŸ“Š Trade History</h2>
                    <button onClick={() => setShowHistory(false)} className="text-white text-2xl">Ã—</button>
                  </div>
                  {tradeHistory.length === 0 ? (
                    <p className="text-purple-300">No trades yet.</p>
                  ) : (
                    <div className="space-y-2 max-h-96 overflow-y-auto">
                      {tradeHistory.map(t => (
                        <div key={t.id} className="bg-slate-800/60 rounded-lg p-3 text-sm">
                          <div className="flex justify-between items-start">
                            <div>
                              <span className={`font-bold ${t.type === 'BUY' ? 'text-green-400' : 'text-red-400'}`}>{t.type}</span>
                              <span className="text-white ml-2">{t.amount.toFixed(6)} {t.crypto}</span>
                              <p className="text-purple-300 text-xs mt-1">{fmtUSD(t.price)} â€¢ Total: {fmtUSD(t.total)}</p>
                              {t.profit !== null && (
                                <p className={`text-xs mt-1 ${t.profit >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                  {t.profit >= 0 ? 'Profit' : 'Loss'}: {fmtUSD(Math.abs(t.profit))}
                                </p>
                              )}
                            </div>
                            <p className="text-purple-400 text-xs">{new Date(t.timestamp).toLocaleString()}</p>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            )}

            <div className="mt-6 text-center">
              <p className="text-purple-300 text-sm">ðŸ’¾ Auto-saves â€¢ Paper trading with real prices (demo)</p>
            </div>
          </div>
        </div>
      );
    }

    // Render using modern React 18 API
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
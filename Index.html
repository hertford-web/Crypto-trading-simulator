<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Crypto Trading Simulator</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Simple SVG Icons
        const Activity = ({ className, size = 24 }) => (
            <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
            </svg>
        );
        
        const TrendingUp = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline>
                <polyline points="17 6 23 6 23 12"></polyline>
            </svg>
        );
        
        const TrendingDown = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline>
                <polyline points="17 18 23 18 23 12"></polyline>
            </svg>
        );
        
        const DollarSign = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="12" y1="1" x2="12" y2="23"></line>
                <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
            </svg>
        );
        
        const RefreshCw = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        );

        const CryptoTracker = () => {
          const [portfolio, setPortfolio] = useState([]);
          const [balance, setBalance] = useState(10000);
          const [prices, setPrices] = useState({});
          const [selectedCrypto, setSelectedCrypto] = useState('bitcoin');
          const [tradeAmount, setTradeAmount] = useState('');
          const [loading, setLoading] = useState(true);
          const [lastUpdate, setLastUpdate] = useState(null);
          const [showStarterSuggestions, setShowStarterSuggestions] = useState(true);
          const [historicalData, setHistoricalData] = useState({});
          const [aiSuggestions, setAiSuggestions] = useState([]);
          const [economicData, setEconomicData] = useState(null);
          const [marketSentiment, setMarketSentiment] = useState({ status: 'neutral', reasoning: 'Analyzing...' });

          const TRADING_FEE_PERCENT = 0.1;

          const cryptoList = [
            { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin' },
            { id: 'ethereum', symbol: 'ETH', name: 'Ethereum' },
            { id: 'binancecoin', symbol: 'BNB', name: 'Binance Coin' },
            { id: 'solana', symbol: 'SOL', name: 'Solana' },
            { id: 'cardano', symbol: 'ADA', name: 'Cardano' },
            { id: 'ripple', symbol: 'XRP', name: 'XRP' }
          ];

          // Load saved data on startup
          useEffect(() => {
            try {
              const savedPortfolio = localStorage.getItem('cryptoPortfolio');
              const savedBalance = localStorage.getItem('cryptoBalance');
              const savedShowStarter = localStorage.getItem('showStarterSuggestions');
              
              if (savedPortfolio) setPortfolio(JSON.parse(savedPortfolio));
              if (savedBalance) setBalance(parseFloat(savedBalance));
              if (savedShowStarter !== null) setShowStarterSuggestions(savedShowStarter === 'true');
            } catch (error) {
              console.error('Error loading saved data:', error);
            }
          }, []);

          // Auto-save portfolio
          useEffect(() => {
            localStorage.setItem('cryptoPortfolio', JSON.stringify(portfolio));
          }, [portfolio]);

          // Auto-save balance
          useEffect(() => {
            localStorage.setItem('cryptoBalance', balance.toString());
          }, [balance]);

          // Auto-save starter state
          useEffect(() => {
            localStorage.setItem('showStarterSuggestions', showStarterSuggestions.toString());
          }, [showStarterSuggestions]);

          // Fetch prices
          const fetchPrices = async () => {
            try {
              const ids = cryptoList.map(c => c.id).join(',');
              const response = await fetch(
                `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24h_change=true`
              );
              const data = await response.json();
              
              const formattedPrices = {};
              Object.keys(data).forEach(id => {
                const crypto = cryptoList.find(c => c.id === id);
                if (crypto) {
                  formattedPrices[crypto.symbol] = {
                    price: data[id].usd,
                    change24h: data[id].usd_24h_change || 0
                  };
                }
              });
              
              setPrices(formattedPrices);
              setLastUpdate(new Date());
              setLoading(false);
            } catch (error) {
              console.error('Error fetching prices:', error);
              setLoading(false);
            }
          };

          // Fetch historical data for technical analysis
          const fetchHistoricalData = async () => {
            try {
              const historicalPromises = cryptoList.map(async (crypto) => {
                const response = await fetch(
                  `https://api.coingecko.com/api/v3/coins/${crypto.id}/market_chart?vs_currency=usd&days=7&interval=daily`
                );
                const data = await response.json();
                return { symbol: crypto.symbol, data: data.prices };
              });
              
              const results = await Promise.all(historicalPromises);
              const historicalObj = {};
              results.forEach(result => {
                historicalObj[result.symbol] = result.data;
              });
              
              setHistoricalData(historicalObj);
            } catch (error) {
              console.error('Error fetching historical data:', error);
            }
          };

          // Fetch economic data
          const fetchEconomicData = async () => {
            try {
              const apiKey = 'O4XA8PH7S02INUTS';
              
              const inflationResponse = await fetch(
                `https://www.alphavantage.co/query?function=INFLATION&apikey=${apiKey}`
              );
              const inflationData = await inflationResponse.json();
              
              const fedFundsResponse = await fetch(
                `https://www.alphavantage.co/query?function=FEDERAL_FUNDS_RATE&apikey=${apiKey}`
              );
              const fedFundsData = await fedFundsResponse.json();

              if (inflationData.data && fedFundsData.data) {
                const latestInflation = inflationData.data[0];
                const latestFedRate = fedFundsData.data[0];
                
                setEconomicData({
                  inflation: parseFloat(latestInflation.value),
                  federalFundsRate: parseFloat(latestFedRate.value)
                });
                
                analyzeMacroSentiment(parseFloat(latestInflation.value), parseFloat(latestFedRate.value));
              } else {
                setEconomicData({ inflation: 3.2, federalFundsRate: 4.5 });
                analyzeMacroSentiment(3.2, 4.5);
              }
            } catch (error) {
              console.error('Error fetching economic data:', error);
              setEconomicData({ inflation: 3.2, federalFundsRate: 4.5 });
              analyzeMacroSentiment(3.2, 4.5);
            }
          };

          const analyzeMacroSentiment = (inflation, fedRate) => {
            let sentiment = 'neutral';
            let reasoning = '';
            
            if (inflation > 4 && fedRate > 5) {
              sentiment = 'bearish';
              reasoning = 'High inflation & rates create risk-off environment for crypto';
            } else if (inflation < 2 && fedRate < 3) {
              sentiment = 'bullish';
              reasoning = 'Low inflation & accommodative policy support risk assets';
            } else if (inflation > 3 && fedRate > 4) {
              sentiment = 'cautious';
              reasoning = 'Elevated rates may pressure speculative assets';
            } else {
              sentiment = 'optimistic';
              reasoning = 'Moderate conditions support crypto growth';
            }
            
            setMarketSentiment({ status: sentiment, reasoning });
          };

          // Calculate RSI
          const calculateRSI = (data, period = 14) => {
            if (data.length < period + 1) return 50;
            
            const changes = [];
            for (let i = 1; i < data.length; i++) {
              changes.push(data[i][1] - data[i - 1][1]);
            }
            
            const recentChanges = changes.slice(-period);
            const gains = recentChanges.filter(c => c > 0).reduce((a, b) => a + b, 0) / period;
            const losses = Math.abs(recentChanges.filter(c => c < 0).reduce((a, b) => a + b, 0)) / period;
            
            if (losses === 0) return 100;
            const rs = gains / losses;
            return 100 - (100 / (1 + rs));
          };

          // Calculate moving average
          const calculateSMA = (data, period) => {
            if (data.length < period) return null;
            const slice = data.slice(-period);
            const sum = slice.reduce((acc, val) => acc + val[1], 0);
            return sum / period;
          };

          // Generate AI trading suggestions
          const generateAISuggestions = () => {
            if (!economicData || Object.keys(historicalData).length === 0) return;
            
            const macroMultiplier = 
              marketSentiment.status === 'bullish' ? 1.5 :
              marketSentiment.status === 'optimistic' ? 1.2 :
              marketSentiment.status === 'cautious' ? 0.8 :
              marketSentiment.status === 'bearish' ? 0.5 : 1.0;
            
            const suggestions = [];
            
            cryptoList.forEach(crypto => {
              const priceData = prices[crypto.symbol];
              const historical = historicalData[crypto.symbol];
              
              if (!priceData || !historical || historical.length < 7) return;
              
              const currentPrice = priceData.price;
              const change24h = priceData.change24h;
              const sma7 = calculateSMA(historical, 7);
              const rsi = calculateRSI(historical);
              
              const holding = portfolio.find(p => p.symbol === crypto.symbol);
              
              let signal = null;
              let reason = '';
              let score = 0;

              // RSI Strategy
              if (rsi < 30) {
                score += 2 * macroMultiplier;
                reason = `Oversold (RSI: ${rsi.toFixed(0)})`;
                signal = 'BUY';
              } else if (rsi > 70) {
                score += 2;
                reason = `Overbought (RSI: ${rsi.toFixed(0)})`;
                signal = 'SELL';
              }

              // Moving Average Strategy
              if (sma7 && currentPrice > sma7 * 1.02) {
                score += 1 * macroMultiplier;
                reason += reason ? ', Above 7-day MA' : 'Above 7-day moving average';
                if (!signal) signal = 'BUY';
              } else if (sma7 && currentPrice < sma7 * 0.98) {
                score += 1;
                reason += reason ? ', Below 7-day MA' : 'Below 7-day moving average';
                if (!signal) signal = 'SELL';
              }

              // Momentum Strategy
              if (change24h > 5) {
                score += 1.5;
                reason += reason ? `, Strong momentum (+${change24h.toFixed(1)}%)` : `Strong momentum (+${change24h.toFixed(1)}%)`;
                if (holding && !signal) signal = 'SELL';
              } else if (change24h < -5) {
                score += 1 * macroMultiplier;
                reason += reason ? `, Sharp decline (${change24h.toFixed(1)}%)` : `Sharp decline (${change24h.toFixed(1)}%)`;
                if (!holding && !signal) signal = 'BUY';
              }

              // Macro factor
              if (marketSentiment.status === 'bullish' || marketSentiment.status === 'optimistic') {
                score += 1;
                reason += ', Favorable macro';
              } else if (marketSentiment.status === 'bearish' && signal === 'BUY') {
                score -= 1.5;
                reason += ', Risk-off environment';
              }

              // Profit/Loss for holdings
              if (holding) {
                const plPercent = ((currentPrice - holding.buyPrice) / holding.buyPrice) * 100;
                if (plPercent > 10) {
                  score += 2.5;
                  reason += `, Take profit (+${plPercent.toFixed(1)}%)`;
                  signal = 'SELL';
                } else if (plPercent < -8) {
                  score += 1.5;
                  reason += `, Stop-loss (${plPercent.toFixed(1)}%)`;
                  signal = 'SELL';
                }
              }

              // Only add strong suggestions
              if (signal && reason && score >= 2) {
                suggestions.push({
                  id: crypto.id,
                  symbol: crypto.symbol,
                  name: crypto.name,
                  action: signal,
                  reason,
                  score,
                  currentPrice,
                  rsi: rsi.toFixed(0),
                  change24h: change24h.toFixed(2),
                  confidence: score >= 5 ? 'High' : score >= 3 ? 'Medium' : 'Low'
                });
              }
            });
            
            suggestions.sort((a, b) => b.score - a.score);
            setAiSuggestions(suggestions.slice(0, 5));
          };

          useEffect(() => {
            fetchPrices();
            fetchHistoricalData();
            fetchEconomicData();
            const interval = setInterval(fetchPrices, 60000);
            return () => clearInterval(interval);
          }, []);

          // Generate AI suggestions when data updates
          useEffect(() => {
            if (Object.keys(prices).length > 0 && Object.keys(historicalData).length > 0 && economicData) {
              generateAISuggestions();
            }
          }, [prices, historicalData, economicData, portfolio]);

          // Execute trade
          const executeTrade = (type, cryptoId = null, amount = null) => {
            const tradeSymbol = cryptoId || selectedCrypto;
            const tradeQty = amount || parseFloat(tradeAmount);
            
            if (!tradeQty || tradeQty <= 0) {
              alert('Please enter a valid amount');
              return;
            }

            const crypto = cryptoList.find(c => c.id === tradeSymbol);
            const priceData = prices[crypto.symbol];
            
            if (!priceData) {
              alert('Price data not available');
              return;
            }

            const price = priceData.price;

            if (type === 'buy') {
              const grossCost = tradeQty * price;
              const fee = grossCost * (TRADING_FEE_PERCENT / 100);
              const totalCost = grossCost + fee;
              
              if (totalCost > balance) {
                alert(`Insufficient funds! Need $${totalCost.toFixed(2)} (includes $${fee.toFixed(2)} fee)`);
                return;
              }
              
              setBalance(balance - totalCost);
              const existing = portfolio.find(p => p.symbol === crypto.symbol);
              
              if (existing) {
                const newAmount = existing.amount + tradeQty;
                const newAvgPrice = ((existing.amount * existing.buyPrice) + (tradeQty * price)) / newAmount;
                setPortfolio(portfolio.map(p => 
                  p.symbol === crypto.symbol 
                    ? { ...p, amount: newAmount, buyPrice: newAvgPrice }
                    : p
                ));
              } else {
                setPortfolio([...portfolio, {
                  id: crypto.id,
                  symbol: crypto.symbol,
                  name: crypto.name,
                  amount: tradeQty,
                  buyPrice: price
                }]);
              }
              
              setShowStarterSuggestions(false);
              setSelectedCrypto(crypto.id);
              alert(`‚úÖ Bought ${tradeQty.toFixed(4)} ${crypto.symbol}\n$${grossCost.toFixed(2)} + $${fee.toFixed(2)} fee = $${totalCost.toFixed(2)}`);
              
            } else {
              const holding = portfolio.find(p => p.symbol === crypto.symbol);
              if (!holding || holding.amount < tradeQty) {
                alert('Insufficient holdings!');
                return;
              }
              
              const grossRevenue = tradeQty * price;
              const fee = grossRevenue * (TRADING_FEE_PERCENT / 100);
              const netRevenue = grossRevenue - fee;
              
              setBalance(balance + netRevenue);
              
              if (holding.amount === tradeQty) {
                setPortfolio(portfolio.filter(p => p.symbol !== crypto.symbol));
              } else {
                setPortfolio(portfolio.map(p => 
                  p.symbol === crypto.symbol 
                    ? { ...p, amount: p.amount - tradeQty }
                    : p
                ));
              }
              
              const costBasis = tradeQty * holding.buyPrice;
              const profit = netRevenue - costBasis;
              
              alert(`‚úÖ Sold ${tradeQty.toFixed(4)} ${crypto.symbol}\n$${grossRevenue.toFixed(2)} - $${fee.toFixed(2)} fee = $${netRevenue.toFixed(2)}\n${profit >= 0 ? 'Profit' : 'Loss'}: $${profit.toFixed(2)}`);
            }
            
            setTradeAmount('');
          };

          // Reset portfolio
          const resetPortfolio = () => {
            if (confirm('‚ö†Ô∏è Reset portfolio to $10,000 and clear all holdings?')) {
              setPortfolio([]);
              setBalance(10000);
              setShowStarterSuggestions(true);
              localStorage.clear();
              alert('‚úÖ Portfolio reset!');
            }
          };

          // Calculate P/L
          const calculateProfitLoss = (holding) => {
            const priceData = prices[holding.symbol];
            if (!priceData) return { pl: 0, plPercent: 0, currentValue: 0 };
            
            const currentPrice = priceData.price;
            const currentValue = holding.amount * currentPrice;
            const costBasis = holding.amount * holding.buyPrice;
            const pl = currentValue - costBasis;
            const plPercent = (pl / costBasis) * 100;
            return { pl, plPercent, currentValue };
          };

          const totalPortfolioValue = portfolio.reduce((sum, holding) => {
            const { currentValue } = calculateProfitLoss(holding);
            return sum + currentValue;
          }, 0);

          const totalValue = balance + totalPortfolioValue;
          const totalPL = totalValue - 10000;
          const totalPLPercent = (totalPL / 10000) * 100;

          // Starter suggestions
          const getStarterSuggestions = () => {
            if (!prices.BTC || !prices.ETH) return [];
            
            return [
              {
                crypto: 'Bitcoin (BTC)',
                id: 'bitcoin',
                symbol: 'BTC',
                amount: 0.1,
                price: prices.BTC.price,
                cost: 0.1 * prices.BTC.price,
                fee: 0.1 * prices.BTC.price * TRADING_FEE_PERCENT / 100,
                reason: 'Most established crypto, portfolio foundation'
              },
              {
                crypto: 'Ethereum (ETH)',
                id: 'ethereum',
                symbol: 'ETH',
                amount: 1,
                price: prices.ETH.price,
                cost: 1 * prices.ETH.price,
                fee: 1 * prices.ETH.price * TRADING_FEE_PERCENT / 100,
                reason: 'Powers smart contracts and DeFi'
              },
              {
                crypto: 'Solana (SOL)',
                id: 'solana',
                symbol: 'SOL',
                amount: 5,
                price: prices.SOL?.price || 110,
                cost: 5 * (prices.SOL?.price || 110),
                fee: 5 * (prices.SOL?.price || 110) * TRADING_FEE_PERCENT / 100,
                reason: 'High-speed transactions, emerging'
              }
            ];
          };

          if (loading) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center">
                <div className="text-center">
                  <RefreshCw className="animate-spin text-purple-400 mx-auto mb-4" size={48} />
                  <p className="text-white text-xl">Loading market data...</p>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4 md:p-6">
              <div className="max-w-7xl mx-auto">
                {/* Header */}
                <div className="flex justify-between items-center mb-6">
                  <h1 className="text-2xl md:text-4xl font-bold text-white flex items-center gap-3">
                    <Activity className="text-purple-400" size={32} />
                    <span className="hidden sm:inline">AI Crypto Simulator</span>
                    <span className="sm:hidden">Crypto</span>
                  </h1>
                  <div className="flex gap-2">
                    <button 
                      onClick={resetPortfolio}
                      className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-sm font-bold"
                      title="Reset portfolio"
                    >
                      üîÑ
                    </button>
                    <button 
                      onClick={fetchPrices}
                      className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded-lg flex items-center gap-2 text-sm"
                    >
                      <RefreshCw size={16} />
                      <span className="hidden sm:inline">Refresh</span>
                    </button>
                  </div>
                </div>

                {lastUpdate && (
                  <div className="flex justify-between items-center mb-4 text-xs md:text-sm">
                    <p className="text-purple-300">
                      Updated: {lastUpdate.toLocaleTimeString()}
                    </p>
                    <p className="text-green-400 flex items-center gap-1">
                      üíæ Auto-saved
                    </p>
                  </div>
                )}

                {/* Account Summary */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
                  <div className="bg-white/10 rounded-xl p-4 border border-white/20">
                    <p className="text-purple-300 text-xs">Cash</p>
                    <p className="text-xl font-bold text-white">${balance.toFixed(0)}</p>
                  </div>
                  
                  <div className="bg-white/10 rounded-xl p-4 border border-white/20">
                    <p className="text-purple-300 text-xs">Portfolio</p>
                    <p className="text-xl font-bold text-white">${totalPortfolioValue.toFixed(0)}</p>
                  </div>
                  
                  <div className="bg-white/10 rounded-xl p-4 border border-white/20">
                    <p className="text-purple-300 text-xs">Total</p>
                    <p className="text-xl font-bold text-white">${totalValue.toFixed(0)}</p>
                  </div>

                  <div className="bg-white/10 rounded-xl p-4 border border-white/20">
                    <p className="text-purple-300 text-xs">P/L</p>
                    <p className={`text-xl font-bold ${totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {totalPL >= 0 ? '+' : ''}${totalPL.toFixed(0)}
                    </p>
                    <p className={`text-xs ${totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {totalPL >= 0 ? '+' : ''}{totalPLPercent.toFixed(1)}%
                    </p>
                  </div>
                </div>

                {/* Starter Suggestions */}
                {showStarterSuggestions && portfolio.length === 0 && prices.BTC && (
                  <div className="bg-gradient-to-r from-purple-600/30 to-blue-600/30 rounded-xl p-4 md:p-6 border-2 border-purple-500/50 mb-6">
                    <h2 className="text-xl md:text-2xl font-bold text-white mb-3">
                      üéØ Recommended Starter Portfolio
                    </h2>
                    <p className="text-purple-200 text-sm mb-4">
                      New to crypto? Start with these balanced picks (0.1% fee per trade):
                    </p>
                    
                    <div className="space-y-3">
                      {getStarterSuggestions().map((starter, idx) => (
                        <div key={idx} className="bg-slate-800/70 rounded-lg p-3 border border-purple-500/30">
                          <div className="flex justify-between items-start mb-2">
                            <div>
                              <h3 className="text-lg font-bold text-white">{starter.crypto}</h3>
                              <p className="text-purple-300 text-xs">{starter.reason}</p>
                            </div>
                          </div>
                          
                          <div className="flex justify-between items-center mt-3">
                            <div className="text-sm">
                              <span className="text-white font-bold">{starter.amount} {starter.symbol}</span>
                              <span className="text-purple-300"> @ ${starter.price.toFixed(2)}</span>
                              <div className="text-xs text-purple-400 mt-1">
                                ${starter.cost.toFixed(2)} + ${starter.fee.toFixed(2)} fee = ${(starter.cost + starter.fee).toFixed(2)}
                              </div>
                            </div>
                            <button
                              onClick={() => executeTrade('buy', starter.id, starter.amount)}
                              className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-bold text-sm"
                            >
                              Buy Now
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                  {/* Left side - Trade Execution + Holdings */}
                  <div className="lg:col-span-2 space-y-6">
                    {/* Trade Execution */}
                    <div className="bg-white/10 rounded-xl p-4 md:p-6 border border-white/20">
                    <h2 className="text-xl font-bold text-white mb-4">Execute Trade</h2>
                    
                    <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3 mb-4">
                      <p className="text-yellow-300 text-xs">
                        üí∞ Trading Fee: {TRADING_FEE_PERCENT}% per trade
                      </p>
                    </div>
                    
                    <div className="space-y-3">
                      <div>
                        <label className="text-purple-300 text-sm mb-2 block">Cryptocurrency</label>
                        <select 
                          value={selectedCrypto}
                          onChange={(e) => setSelectedCrypto(e.target.value)}
                          className="w-full bg-slate-800 text-white rounded-lg p-3 border border-purple-500/30"
                        >
                          {cryptoList.map(crypto => (
                            <option key={crypto.id} value={crypto.id}>
                              {crypto.symbol} - {crypto.name}
                            </option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="text-purple-300 text-sm mb-2 block">Amount (coins)</label>
                        <input 
                          type="number"
                          value={tradeAmount}
                          onChange={(e) => setTradeAmount(e.target.value)}
                          placeholder="0.00"
                          className="w-full bg-slate-800 text-white rounded-lg p-3 border border-purple-500/30"
                          step="0.001"
                        />
                      </div>
                    </div>
                    
                    <div className="mt-4 p-4 bg-slate-800/50 rounded-lg">
                      {(() => {
                        const crypto = cryptoList.find(c => c.id === selectedCrypto);
                        const priceData = prices[crypto?.symbol];
                        const qty = parseFloat(tradeAmount) || 0;
                        const grossCost = qty * (priceData?.price || 0);
                        const fee = grossCost * (TRADING_FEE_PERCENT / 100);
                        
                        return (
                          <>
                            <p className="text-purple-300 text-sm">Current Price</p>
                            <p className="text-2xl font-bold text-white">
                              ${priceData?.price.toFixed(2) || '‚Äî'}
                            </p>
                            {tradeAmount && priceData && (
                              <div className="mt-3 space-y-1 text-sm">
                                <p className="text-purple-300">Cost: ${grossCost.toFixed(2)}</p>
                                <p className="text-purple-300">Fee: ${fee.toFixed(2)}</p>
                                <p className="text-white font-bold border-t border-purple-500/30 pt-2">
                                  Total: ${(grossCost + fee).toFixed(2)}
                                </p>
                              </div>
                            )}
                          </>
                        );
                      })()}
                    </div>
                    
                    <div className="flex gap-4 mt-4">
                      <button 
                        onClick={() => executeTrade('buy')}
                        className="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg"
                      >
                        BUY
                      </button>
                      <button 
                        onClick={() => executeTrade('sell')}
                        className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-lg"
                      >
                        SELL
                      </button>
                    </div>
                  </div>

                  {/* Portfolio Holdings */}
                  <div className="bg-white/10 rounded-xl p-4 md:p-6 border border-white/20">
                    <h2 className="text-xl font-bold text-white mb-4">Your Holdings</h2>
                    {portfolio.length === 0 ? (
                      <p className="text-purple-300">No holdings yet. Start trading!</p>
                    ) : (
                      <div className="space-y-3">
                        {portfolio.map(holding => {
                          const { pl, plPercent, currentValue } = calculateProfitLoss(holding);
                          const isProfit = pl >= 0;
                          const priceData = prices[holding.symbol];
                          
                          return (
                            <div key={holding.symbol} className="bg-slate-800/50 rounded-lg p-4">
                              <div className="flex justify-between items-start mb-2">
                                <div>
                                  <h3 className="text-xl font-bold text-white">{holding.symbol}</h3>
                                  <p className="text-purple-300 text-sm">{holding.amount.toFixed(4)} coins</p>
                                </div>
                                <div className="text-right">
                                  <p className="text-xl font-bold text-white">${currentValue.toFixed(2)}</p>
                                  <div className={`flex items-center gap-1 justify-end ${isProfit ? 'text-green-400' : 'text-red-400'}`}>
                                    {isProfit ? <TrendingUp size={16} /> : <TrendingDown size={16} />}
                                    <span className="text-sm font-bold">
                                      {isProfit ? '+' : ''}{plPercent.toFixed(2)}%
                                    </span>
                                  </div>
                                </div>
                              </div>
                              <div className="flex justify-between text-xs text-purple-300 mb-3">
                                <span>Buy: ${holding.buyPrice.toFixed(2)}</span>
                                <span>Now: ${priceData?.price.toFixed(2) || '‚Äî'}</span>
                                <span className={isProfit ? 'text-green-400' : 'text-red-400'}>
                                  {isProfit ? '+' : ''}${pl.toFixed(2)}
                                </span>
                              </div>
                              <div className="flex gap-2">
                                <button
                                  onClick={() => {
                                    setSelectedCrypto(holding.id);
                                    setTradeAmount(holding.amount.toString());
                                  }}
                                  className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-lg text-xs font-bold"
                                >
                                  Select
                                </button>
                                <button
                                  onClick={() => {
                                    if (confirm(`Sell all ${holding.amount.toFixed(4)} ${holding.symbol}?`)) {
                                      executeTrade('sell', holding.id, holding.amount);
                                    }
                                  }}
                                  className="flex-1 bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-xs font-bold"
                                >
                                  Sell All
                                </button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                </div>
                </div>

                <div className="mt-6 text-center space-y-2">
                  <p className="text-purple-300 text-sm">
                    üíæ Your portfolio auto-saves! Close and reopen - your trades persist.
                  </p>
                  <p className="text-purple-300 text-xs">
                    ‚ö†Ô∏è Educational tool only. Not financial advice.
                  </p>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<CryptoTracker />, document.getElementById('root'));
    </script>
</body>
</html>